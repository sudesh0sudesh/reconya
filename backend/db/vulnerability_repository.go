package db

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/google/uuid"
	"reconya-ai/models"
)

// SQLiteVulnerabilityRepository implements VulnerabilityRepository for SQLite.
type SQLiteVulnerabilityRepository struct {
	db *sql.DB
}

// NewSQLiteVulnerabilityRepository creates a new repository instance.
func NewSQLiteVulnerabilityRepository(db *sql.DB) *SQLiteVulnerabilityRepository {
	return &SQLiteVulnerabilityRepository{db: db}
}

// Close satisfies the Repository interface. No action required for SQLite.
func (r *SQLiteVulnerabilityRepository) Close() error { return nil }

// Create stores a new vulnerability record.
func (r *SQLiteVulnerabilityRepository) Create(ctx context.Context, v *models.Vulnerability) error {
	if v.ID == "" {
		v.ID = uuid.New().String()
	}
	if v.DiscoveredAt.IsZero() {
		v.DiscoveredAt = time.Now()
	}

	query := `INSERT INTO vulnerabilities (id, device_id, target, name, description, severity, discovered_at)
              VALUES (?, ?, ?, ?, ?, ?, ?)`

	_, err := r.db.ExecContext(ctx, query, v.ID, v.DeviceID, v.Target, v.Name, v.Description, v.Severity, v.DiscoveredAt)
	if err != nil {
		return fmt.Errorf("failed to create vulnerability: %w", err)
	}
	return nil
}

// FindByDeviceID retrieves vulnerabilities for a specific device.
func (r *SQLiteVulnerabilityRepository) FindByDeviceID(ctx context.Context, deviceID string) ([]*models.Vulnerability, error) {
	query := `SELECT id, device_id, target, name, description, severity, discovered_at
              FROM vulnerabilities WHERE device_id = ? ORDER BY discovered_at DESC`

	rows, err := r.db.QueryContext(ctx, query, deviceID)
	if err != nil {
		return nil, fmt.Errorf("failed to query vulnerabilities: %w", err)
	}
	defer rows.Close()

	var vulns []*models.Vulnerability
	for rows.Next() {
		var v models.Vulnerability
		if err := rows.Scan(&v.ID, &v.DeviceID, &v.Target, &v.Name, &v.Description, &v.Severity, &v.DiscoveredAt); err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
		}
		vulns = append(vulns, &v)
	}
	return vulns, nil
}

// FindAll returns the most recent vulnerabilities.
func (r *SQLiteVulnerabilityRepository) FindAll(ctx context.Context) ([]*models.Vulnerability, error) {
	query := `SELECT id, device_id, target, name, description, severity, discovered_at
              FROM vulnerabilities ORDER BY discovered_at DESC LIMIT 100`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query vulnerabilities: %w", err)
	}
	defer rows.Close()

	var vulns []*models.Vulnerability
	for rows.Next() {
		var v models.Vulnerability
		if err := rows.Scan(&v.ID, &v.DeviceID, &v.Target, &v.Name, &v.Description, &v.Severity, &v.DiscoveredAt); err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
		}
		vulns = append(vulns, &v)
	}
	return vulns, nil
}
